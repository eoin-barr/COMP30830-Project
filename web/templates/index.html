<!DOCTYPE html>
<html>
  <head>
    <title>Locator</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/handlebars/4.7.7/handlebars.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">

    <link
      href="https://fonts.googleapis.com/css?family=Roboto"
      rel="stylesheet"
/>
    <link
      rel="stylesheet"
      type="text/css"
      href="{{ url_for('static',filename='styles/maps.css') }}"
    />
    
    <script type=text/javascript>
      $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
    </script>

</head>
<body>
  <div id="map-container">
    <div id="locations-panel">
      <div id="locations-panel-list">
        <div>                
          <select id="stationsList" class="form-select">
        
          </select>
        </div>
        <!-- <header>
 
          <h1 class="search-title">
            <img
              src="https://fonts.gstatic.com/s/i/googlematerialicons/place/v15/24px.svg"
            />
            Find a location near you
          </h1>
          <div class="search-input">
            <input
              id="location-search-input"
              placeholder="Enter your address or zip code"
            />

            <div
              id="search-overlay-search"
              class="search-input-overlay search"
            >
              <button id="location-search-button">
                <img
                  class="icon"
                  src="https://fonts.gstatic.com/s/i/googlematerialicons/search/v11/24px.svg"
                  alt="Search"
                />
              </button>
            </div>
          </div>
        </header> -->
        <!-- <div class="section-name" id="location-results-section-name">
          All locations
        </div>
        <div class="results">
          <ul id="location-results-list"></ul>
        </div> -->
      </div>
    </div>
    <div id="map"></div>
  </div>

    <script>
      "use strict";

      /**
       * Defines an instance of the Locator+ solution, to be instantiated
       * when the Maps library is loaded.
       */
      function LocatorPlus(configuration) {
        const locator = this;

        locator.locations = configuration.locations || [];
        locator.capabilities = configuration.capabilities || {};

        const mapEl = document.getElementById("map");
        const panelEl = document.getElementById("locations-panel");
        locator.panelListEl = document.getElementById("locations-panel-list");
        const sectionNameEl = document.getElementById("location-results-section-name");
        const resultsContainerEl = document.getElementById("location-results-list");

        // const itemsTemplate = Handlebars.compile(
        //     document.getElementById('locator-result-items-tmpl').innerHTML);
        locator.searchLocation = null;
        locator.searchLocationMarker = null;
        locator.selectedLocationIdx = null;
        locator.userCountry = null;

        // Initialize the map -------------------------------------------------------
        locator.map = new google.maps.Map(mapEl, configuration.mapOptions);

        // Store selection.
        const selectResultItem = function (
          locationIdx,
          panToMarker,
          scrollToResult
        ) {
          locator.selectedLocationIdx = locationIdx;
          for (let locationElem of resultsContainerEl.children) {
            locationElem.classList.remove("selected");
            if (getResultIndex(locationElem) === locator.selectedLocationIdx) {
              locationElem.classList.add("selected");
              if (scrollToResult) {
                panelEl.scrollTop = locationElem.offsetTop;
              }
            }
          }
          if (panToMarker && locationIdx != null) {
            locator.map.panTo(locator.locations[locationIdx].coords);
          }
        };
        // Pans to chosen station in select + zoom
        function chosenstation(){
          let index = document.getElementById("stationsList").value;
          locator.map.panTo(locator.locations[index].coords);
          // Set zoom level when changing station
          locator.map.setZoom(200);
        };

        document.getElementById("stationsList").onchange = chosenstation;

        // Create one instance of an info window
        const infoWindow = new google.maps.InfoWindow({ minWidth: 500 });

        // const getColour=(i) => {
        //   console.log('i', i)
        //   console.log('number', i.number)
        //     var colour;
        //     const recentbike = $.getJSON($SCRIPT_ROOT + "/occupancy/" + i.number,
        //     function(bikeData) {
        //       if(parseInt(bikeData.available_bikes)>15){
        //         colour = 'http://maps.google.com/mapfiles/ms/icons/green-dot.png'
        //       }
        //       else {
        //         colour = 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'
        //       }
        //       console.log(colour)
        //       return colour
        //     }
        //     )
        //   }

        // const json_means = require("../means_json.json")
        // console.log(json_means)
  
        const weekday = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];

        

        // Create a marker for each location

        

        const markers = locator.locations.map(function (location, index) {
          
          const marker = new google.maps.Marker({
            position: location.coords,
            map: locator.map,
            title: location.title,
            
            // icon: getColour(location),
          });

          

          marker.addListener("click", function () {
            infoWindow.open({
              anchor: marker,
              map,
              shouldFocus: false,
            });
            const recentbike = $.getJSON($SCRIPT_ROOT + "/occupancy/" + location.number,
            function(bikeData) {
              const currentDate = new Date(bikeData.last_update*1);
              const stringCurrentDateTime = currentDate.toLocaleString().replace(',','');
              
              const stationNumber = parseInt(location.number);
         
              const displayText = `<div>
                              <h5>${location.address}</h5>
                              <p>Last Updated: ${stringCurrentDateTime}</p>
                              <p>Number of Available Bikes: ${bikeData.available_bikes}</p>
                              <p>Number of Available Bike Stands: ${bikeData.available_bike_stands}</p>
                              </div>
                              <div> 
                                <canvas id="myChart"></canvas>
                              </div>`;
              infoWindow.setContent(displayText);
              
              const labels = [
                  '06:00',
                  '07:00',
                  '08:00',
                  '09:00',
                  '10:00',
                  '11:00',
                  '12:00',
                  '13:00',
                  '14:00',
                  '15:00',
                  '16:00',
                  '17:00',
                  '18:00',
                  '19:00',
                  '20:00',
                  '21:00',
                  '22:00',
                  '23:00',
                  
                ];
                // get current day of week
                const d = new Date();
                let day = weekday[d.getDay()];
                console.log(day)
                const data = {
                  labels: labels,
                  datasets: [{
                    label: 'Available Bikes',
                    backgroundColor: 'rgb(255, 99, 132)',
                    borderColor: 'rgb(255, 99, 132)',
                    
                    data: means[stationNumber][day],
                  }]
                };

                const config = {
                  type: 'bar',
      
                  data: data,
                  options: {
                    plugins: {
                      title: {
                        display: true,
                        text: 'Average Availability per Hour on ' + day + '\'s'
                      }, 
                      legend: {
                        display: false
                      }
                    },
                    scales: {
                      y: {
                        beginAtZero: true
                      }, 
                      x: {
                        ticks: {
                          maxTicksLimit: labels.length / 2
                        }
                      }
                    }
                  }
                };

                const myChart = new Chart(
                  document.getElementById('myChart'),
                  config
                );
             
              })

            selectResultItem(index, true, true);
          });
          return marker;
        });

        console.log('markers', markers)
        // Fit map to marker bounds.
        locator.updateBounds = function () {
          const bounds = new google.maps.LatLngBounds();
          if (locator.searchLocationMarker) {
            bounds.extend(locator.searchLocationMarker.getPosition());
          }
          for (let i = 0; i < markers.length; i++) {
            bounds.extend(markers[i].getPosition());
          }
          locator.map.fitBounds(bounds);
        };
        if (locator.locations.length) {
          locator.updateBounds();
        }

        // Get the distance of a store location to the user's location,
        // used in sorting the list.
        const getLocationDistance = function (location) {
          if (!locator.searchLocation) return null;

          // Use travel distance if available (from Distance Matrix).
          if (location.travelDistanceValue != null) {
            return location.travelDistanceValue;
          }

          // Fall back to straight-line distance.
          return google.maps.geometry.spherical.computeDistanceBetween(
            new google.maps.LatLng(location.coords),
            locator.searchLocation.location
          );
        };

        // Render the results list --------------------------------------------------
        const getResultIndex = function (elem) {
          return parseInt(elem.getAttribute("data-location-index"));
        };

        locator.renderResultsList = function () {
          let locations = locator.locations.slice();
          for (let i = 0; i < locations.length; i++) {
            locations[i].index = i;
          }
          if (locator.searchLocation) {
            sectionNameEl.textContent =
              "Nearest locations (" + locations.length + ")";
            locations.sort(function (a, b) {
              return getLocationDistance(a) - getLocationDistance(b);
            });
          } else {
            sectionNameEl.textContent = `All locations (${locations.length})`;
          }
          const resultItemContext = { locations: locations };
          resultsContainerEl.innerHTML = itemsTemplate(resultItemContext);
          for (let item of resultsContainerEl.children) {
            const resultIndex = getResultIndex(item);
            if (resultIndex === locator.selectedLocationIdx) {
              item.classList.add("selected");
            }

            const resultSelectionHandler = function () {
              selectResultItem(resultIndex, true, false);
            };

            // Clicking anywhere on the item selects this location.
            // Additionally, create a button element to make this behavior
            // accessible under tab navigation.
            item.addEventListener("click", resultSelectionHandler);
            item
              .querySelector(".select-location")
              .addEventListener("click", function (e) {
                resultSelectionHandler();
                e.stopPropagation();
              });
          }
        };

        // Optional capability initialization --------------------------------------
        initializeSearchInput(locator);
        initializeDistanceMatrix(locator);

        // Initial render of results -----------------------------------------------
        locator.renderResultsList();
      }

      /** When the search input capability is enabled, initialize it. */
      function initializeSearchInput(locator) {
        const geocodeCache = new Map();
        const geocoder = new google.maps.Geocoder();

        const searchInputEl = document.getElementById("location-search-input");
        const searchButtonEl = document.getElementById(
          "location-search-button"
        );

        const updateSearchLocation = function (address, location) {
          if (locator.searchLocationMarker) {
            locator.searchLocationMarker.setMap(null);
          }
          if (!location) {
            locator.searchLocation = null;
            return;
          }
          locator.searchLocation = { address: address, location: location };
          locator.searchLocationMarker = new google.maps.Marker({
            position: location,
            map: locator.map,
            title: "My location",
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 12,
              fillColor: "#3367D6",
              fillOpacity: 0.5,
              strokeOpacity: 0,
            },
          });

          // Update the locator's idea of the user's country, used for units. Use
          // `formatted_address` instead of the more structured `address_components`
          // to avoid an additional billed call.
          const addressParts = address.split(" ");
          locator.userCountry = addressParts[addressParts.length - 1];

          // Update map bounds to include the new location marker.
          locator.updateBounds();

          // Update the result list so we can sort it by proximity.
          locator.renderResultsList();

          locator.updateTravelTimes();
        };

        const geocodeSearch = function (query) {
          if (!query) {
            return;
          }

          const handleResult = function (geocodeResult) {
            searchInputEl.value = geocodeResult.formatted_address;
            updateSearchLocation(
              geocodeResult.formatted_address,
              geocodeResult.geometry.location
            );
          };

          if (geocodeCache.has(query)) {
            handleResult(geocodeCache.get(query));
            return;
          }
          const request = { address: query, bounds: locator.map.getBounds() };
          geocoder.geocode(request, function (results, status) {
            if (status === "OK") {
              if (results.length > 0) {
                const result = results[0];
                geocodeCache.set(query, result);
                handleResult(result);
              }
            }
          });
        };

        // Set up geocoding on the search input.
        searchButtonEl.addEventListener("click", function () {
          geocodeSearch(searchInputEl.value.trim());
        });

        // Initialize Autocomplete.
        initializeSearchInputAutocomplete(
          locator,
          searchInputEl,
          geocodeSearch,
          updateSearchLocation
        );
      }

      /** Add Autocomplete to the search input. */
      function initializeSearchInputAutocomplete(
        locator,
        searchInputEl,
        fallbackSearch,
        searchLocationUpdater
      ) {
        // Set up Autocomplete on the search input. Bias results to map viewport.
        const autocomplete = new google.maps.places.Autocomplete(
          searchInputEl,
          {
            types: ["geocode"],
            fields: ["place_id", "formatted_address", "geometry.location"],
          }
        );
        autocomplete.bindTo("bounds", locator.map);
        autocomplete.addListener("place_changed", function () {
          const placeResult = autocomplete.getPlace();
          if (!placeResult.geometry) {
            // Hitting 'Enter' without selecting a suggestion will result in a
            // placeResult with only the text input value as the 'name' field.
            fallbackSearch(placeResult.name);
            return;
          }
          searchLocationUpdater(
            placeResult.formatted_address,
            placeResult.geometry.location
          );
        });
      }

      /** Initialize Distance Matrix for the locator. */
      function initializeDistanceMatrix(locator) {
        const distanceMatrixService = new google.maps.DistanceMatrixService();

        // Annotate travel times to the selected location using Distance Matrix.
        locator.updateTravelTimes = function () {
          if (!locator.searchLocation) return;

          const units =
            locator.userCountry === "USA"
              ? google.maps.UnitSystem.IMPERIAL
              : google.maps.UnitSystem.METRIC;
          const request = {
            origins: [locator.searchLocation.location],
            destinations: locator.locations.map(function (x) {
              return x.coords;
            }),
            travelMode: google.maps.TravelMode.DRIVING,
            unitSystem: units,
          };
          const callback = function (response, status) {
            if (status === "OK") {
              const distances = response.rows[0].elements;
              for (let i = 0; i < distances.length; i++) {
                const distResult = distances[i];
                let travelDistanceText, travelDistanceValue;
                if (distResult.status === "OK") {
                  travelDistanceText = distResult.distance.text;
                  travelDistanceValue = distResult.distance.value;
                }
                const location = locator.locations[i];
                location.travelDistanceText = travelDistanceText;
                location.travelDistanceValue = travelDistanceValue;
              }

              // Re-render the results list, in case the ordering has changed.
              locator.renderResultsList();
            }
          };
          distanceMatrixService.getDistanceMatrix(request, callback);
        };
      }
    </script>
  
    <script>

      const data = {{ static_data|tojson }};
      const means = {{ means|tojson }};
      data.map(row => {
          row.coords.lat = parseFloat(row.coords.lat);
          row.coords.lng = parseFloat(row.coords.lng);
      })
      console.log(data);
    const CONFIGURATION = {
      "locations": data,
      "mapOptions": {"center":{"lat":38.0,"lng":-100.0}, "fullscreenControl":true,"mapTypeControl":false,"streetViewControl":false,"zoom":2,"zoomControl":true,"maxZoom":17},
      "mapsApiKey": "AIzaSyAwcd17hVt4kEa00VW5DIv5BYItdB4BnZA",
      "capabilities": {"input":true,"autocomplete":true,"directions":false,"distanceMatrix":true,"details":false}
    };
    // add station name options to select
    const options = data.map((station, idx) => {
      return `<option value=${idx}>${station.address}</option>`
    })
    let select = `<option value='-1'>--Select a Bike Station--</option>`+`${options}`;
    document.getElementById("stationsList").innerHTML = select;

    function initMap() {
      new LocatorPlus(CONFIGURATION);
    }
  </script>

    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAwcd17hVt4kEa00VW5DIv5BYItdB4BnZA&callback=initMap&libraries=places,geometry&solution_channel=GMP_QB_locatorplus_v4_cABD"
      async
      defer
    ></script>
  </body>
</html>
