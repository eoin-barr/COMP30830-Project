<!DOCTYPE html>
<html>
  <head>
    <title>Bike Locator</title>
    <meta charset="utf-8" />
    <link rel="shortcut icon" type="image/png" href="https://res.cloudinary.com/dk0r9bcxy/image/upload/v1638291047/WAD/logo4_bpwnsi.png">
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/handlebars/4.7.7/handlebars.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://kit.fontawesome.com/ab2155e76b.js" crossorigin="anonymous"></script>

    <link
      href="https://fonts.googleapis.com/css?family=Roboto"
      rel="stylesheet"
/>
    <link
      rel="stylesheet"
      type="text/css"
      href="{{ url_for('static',filename='styles/maps.css') }}"
    />
    <script type=text/javascript>
      $SCRIPT_ROOT = {{ request.script_root|tojson|safe }};
    </script>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

</head>
<body>
  <div id="map-container">
    <div id="locations-panel">
      <div id="locations-panel-list">
        <div class="mx-2">
          <div>
            <div class="mt-3">
              <h4 class="font-weight-normal">Weather Update</h4>
            </div>        
            <div id="currentWeather">

            </div>
          </div>
          <!-- <div class="btn-group" data-toggle="buttons">
            <label class="btn btn-primary">
              <input type="radio" name="options" id="option1"> Option 1
            </label>
            <label class="btn btn-primary">
              <input type="radio" name="options" id="option2"> Option 2
            </label>
            <label class="btn btn-primary">
              <input type="radio" name="options" id="option3"> Option 3
            </label>
          </div> -->
          <!-- <div class="btn-group" role="group" data-toggle="buttons" aria-label="Basic radio toggle button group">
            <input type="radio" class="btn-check" name="btnradio" id="btnradio1" autocomplete="off" checked>
            <label class="btn btn-outline-primary" for="btnradio1">Radio 1</label>
          
            <input type="radio" class="btn-check" name="btnradio" id="btnradio2" autocomplete="off">
            <label class="btn btn-outline-primary" for="btnradio2">Radio 2</label>
          
            <input type="radio" class="btn-check" name="btnradio" id="btnradio3" autocomplete="off">
            <label class="btn btn-outline-primary" for="btnradio3">Radio 3</label>
          </div> -->
          <div class="mt-3">
            <h4 class="font-weight-normal">Check Availability</h4>
            <div class="btn-group" role="group" data-toggle="buttons" id="choices">
              <label class="btn btn-primary" id="bikeLabel">
                <input type="radio" class="btn-check" name="choice" value="bike" id="bikeRadio" autocomplete="off">
                    Bikes</label>
                    <label class="btn btn-primary" id="standsLabel">
                <input type="radio" class="btn-check" name="choice" value="stands" id="standsRadio" autocomplete="off">
                    Stands</label>
                    </div>
          </div> 
          <div>
            <div class="mt-3">
              <h4 class="font-weight-normal">Find a Station</h4>
            </div>        
            <select id="stationsList" class="form-select form-select-lg py-2 mb-3 rounded">
            </select>

            <!-- Button for finding current location -->
            <div class="col-xs-offset-2 col-xs-10 mt-1">
              <button id="locationGetter" class="btn btn-info btn-lg" >
                <i class="fas fa-crosshairs"></i>
              </button>
            </div>

          </div>
          <div class="mt-6">
            <div class="mt-3">
              <h4 class="font-weight-normal">Plan Your Journey</h4>
              <form class="form-horizontal">
          <div class="form-group">
            <!-- <label for="from" class="col-xs-2 control-label"
              ><i class="far fa-dot-circle"></i></label> -->
            <div class="col-xs-4">                                          
              <select id="originStationsList" class="form-select form-select-lg py-2 mb-1 rounded"></select>
            
            </div>
          </div>
          <div class="form-group">
          <div class="col-xs-4">
            <p style="padding-bottom: 6px;" class="font-weight-normal">Choose your start time (optional)</p>
              <input type="datetime-local" id="dateSelection" class="form-control form-control py-2 mb-1 rounded">
          </div></div>
          <div class="form-group">
            <!-- <label for="to" class="col-xs-2 control-label"
              ><i class="fas fa-map-marker-alt"></i
            ></label> -->
            <div class="col-xs-4">
            <select id="destinationStationsList" class="form-select form-select-lg py-2 mb-1 rounded"></select>
            </div>
          </div>
        </form>

        <div class="col-xs-offset-2 col-xs-10">
          <button id="btn" class="btn btn-info btn-lg" >
            <i class="fas fa-map-signs"></i>
          </button>
          <button id="resetbtn" class="btn btn-info btn-lg" >
            Reset
          </button>
        </div>
        
            </div>  
          </div>
          
          <h4 id="outputTitle"></h4>
          <div id="predictionOrigin"></div>
          <div id="predictionDestinationETA"></div>
          <div id="predictionDestination"></div>
          
          <div id="outputGroup">
          
          <div id="output"></div>
          <div id="directions" class="directions"></div>
          </div>
          <div id="homeStation" class="pt-4"></div>

          
        
        </div>
      </div>
    </div>
    <div id="map"></div>
  </div>

    <script>
      "use strict";
      /**
       * Defines an instance of the Locator+ solution, to be instantiated
       * when the Maps library is loaded.
       */

      //initialise radio option
      document.getElementById("bikeRadio").checked = true; //default for bikeRadio to be checked (and displayed)
      
      const bikeRadio = document.getElementById("bikeRadio")
      bikeRadio.addEventListener("change", colourSet)
      const standsRadio = document.getElementById("standsRadio")
      standsRadio.addEventListener("change", colourSet)

      function colourSet() {
      
        if (standsRadio.checked) {
          document.getElementById("standsLabel").style.borderColor = "#0275d8";
          document.getElementById("standsLabel").style.backgroundColor = "#0275d8";
          document.getElementById("bikeLabel").style.backgroundColor = "white";
          document.getElementById("standsLabel").style.color = "white";
          document.getElementById("bikeLabel").style.color = "#0275d8";
        }
        else {
          document.getElementById("bikeLabel").style.borderColor = "#0275d8";
          document.getElementById("bikeLabel").style.backgroundColor = "#0275d8";
          document.getElementById("standsLabel").style.backgroundColor = "white";
          document.getElementById("bikeLabel").style.color = "white";
          document.getElementById("standsLabel").style.color = "#0275d8";
        }
      }
      colourSet()



      
      
      var dateElem = document.getElementById("dateSelection")
      var iso = new Date().toISOString()
      
      console.log(iso)
      // get down to minutes
      var minDate = iso.substring(0,iso.length-8);
   
      dateElem.min = minDate
      //document.getElementById("dateSelection").setAttribute("min", today);
      function LocatorPlus(configuration) {
        const locator = this;

        locator.locations = configuration.locations || [];
        locator.capabilities = configuration.capabilities || {};

        const mapEl = document.getElementById("map");
        const panelEl = document.getElementById("locations-panel");
        locator.panelListEl = document.getElementById("locations-panel-list");
        const sectionNameEl = document.getElementById("location-results-section-name");
        const resultsContainerEl = document.getElementById("location-results-list");

        // const itemsTemplate = Handlebars.compile(
        //     document.getElementById('locator-result-items-tmpl').innerHTML);
        locator.searchLocation = null;
        locator.searchLocationMarker = null;
        locator.selectedLocationIdx = null;
        locator.userCountry = null;

        // Initialize the map -------------------------------------------------------
        locator.map = new google.maps.Map(mapEl, configuration.mapOptions);
        
        // Implement geolocation button
        // Access location button
        const locationButton = document.getElementById("locationGetter");

        // Declare the marker outside so we don't have duplicates
        var locationMarker; 

        // On Click for button
        locationButton.addEventListener("click", () => {
          // Try HTML5 geolocation.
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              (position) => {

                // Current location coords
                const pos = {
                  lat: position.coords.latitude,
                  lng: position.coords.longitude,
                };

                // Define current location svg
                const locationSvg = {
                  path: google.maps.SymbolPath.CIRCLE,	
                  fillColor: "blue",
                  strokeColor: "white",
                  fillOpacity: 0.6,
                  strokeWeight: 1,
                  rotation: 330,
                  scale: 10
                };
                
                // Create current location marker
                locationMarker = new google.maps.Marker({
                  position: pos,
                  map: locator.map,
                  icon: locationSvg
                });
                
                // Pan and set zoom
                locator.map.panTo(pos)
                locator.map.setZoom(15);

              },

              // Error handling for current location
              () => {
                handleLocationError(true);
              }
            );
          } else {
            // Browser doesn't support Geolocation
            handleLocationError(false);
          }
        });

        // Function for current location error
        function handleLocationError(browserHasGeolocation) {
          alert(
            browserHasGeolocation
              ? "Error: The Geolocation service failed."
              : "Error: Your browser doesn't support geolocation."
          );
        }

        //create a DirectionsService object to use the route method and get a result for our request
        var directionsService = new google.maps.DirectionsService();

        //create a DirectionsRenderer object which we will use to display the route
        var directionsDisplay = new google.maps.DirectionsRenderer();

        //bind the DirectionsRenderer to the map
        directionsDisplay.setMap(locator.map);

        const homeStation = window.localStorage.getItem('station')
        const homeStationID = window.localStorage.getItem('stationID')
        if (!homeStation){
        }else {
          let station = document.getElementById("homeStation")
          station.innerHTML= `<h4 class="font-weight-normal">Recent Start Station</h4><div class="d-inline-block"><button value='${homeStationID}' id="homeStationBtn" class="rounded">${homeStation}</button></div>`
          const homeStationBtn = document.getElementById("homeStationBtn");
          function panToStation(){
            locator.map.panTo(locator.locations[parseInt(homeStationBtn.value)].coords)
            locator.map.setZoom(200);
          }
          homeStationBtn.addEventListener('click', panToStation)
        }

        function setLocalStorage(stationInfoArr){
          if (stationInfoArr[0] == -1){
            return
          }
          // let ls = window.localStorage.getItem('station')
          window.localStorage.setItem('station', stationInfoArr[2])
          window.localStorage.setItem('stationID', stationInfoArr[3])
        }
        
        function calcRoute() {  
            
          const originLocation = {
            lat: parseFloat(document.getElementById("originStationsList").value.split("|")[0]),
            lng: parseFloat(document.getElementById("originStationsList").value.split("|")[1]),
          };
          const destinationLocation = {
            lat: parseFloat(document.getElementById("destinationStationsList").value.split("|")[0]),
            lng: parseFloat(document.getElementById("destinationStationsList").value.split("|")[1]),
          };

          //create request
          var request = {
            origin: originLocation,
            destination: destinationLocation,
            travelMode: google.maps.TravelMode.BICYCLING, //WALKING, BYCYCLING, TRANSIT
            unitSystem: google.maps.UnitSystem.METRIC,
          };

          //pass the request to the route method
          directionsService.route(request, function (result, status) {
            const output = document.querySelector("#output");

            if (status == google.maps.DirectionsStatus.OK) {
              setLocalStorage(document.getElementById("originStationsList").value.split("|"))

              // get time of journey for predicting availability at destination
              var routeTimeInt = parseInt(result.routes[0].legs[0].duration.text.split(" ")[0])
              console.log(routeTimeInt)
              //Get distance and time
              output.innerHTML =
                "<p>Duration: " +
                result.routes[0].legs[0].duration.text +
                ".</p><p>Cycling distance: " +
                result.routes[0].legs[0].distance.text +
                ".</p></div>";
                output.classList.add("pb-2")

              //display route
              directionsDisplay.setDirections(result);
              const outputGroup = document.getElementById("outputGroup")
              const outputTitle = document.getElementById("outputTitle");
              outputTitle.innerHTML = "Journey Details"
              outputTitle.classList.add("font-weight-normal", "mt-4")

              outputGroup.classList.add("border", "border-secondary", "rounded", "directions", "p-2");
              // set directions to null so that they don't double up if doing >1 journey
              document.getElementById('directions').innerHTML = "";
              const directions = document.getElementById("directions")
              result.routes[0].legs[0].steps.map(step => {
                let node = document.createElement("p")
                node.innerHTML = step.instructions;
                directions.appendChild(node)
              })
            } else {
              //delete route from map
              directionsDisplay.setDirections({ routes: [] });
              //center map in London
              // map.setCenter(myLatLng);

              //show error message
              output.innerHTML =
                "<div id='journeyError' class='pt-2'><i class='fas fa-exclamation-triangle'></i> Invalid journey selection.</div>";
            }

          if ((document.getElementById("originStationsList").value != -1) && (document.getElementById("dateSelection").value !== ""))  {
          const predictTime = new Date(document.getElementById("dateSelection").value);
          const minutes = predictTime.getMinutes()
          const predictedArrivalTime = new Date(predictTime.getTime() + 60000* routeTimeInt)
          console.log(document.getElementById("dateSelection").value)
          const roundedPredictTime = new Date(roundMinutes(predictTime));
          console.log('time', roundedPredictTime.getDay());
          function roundMinutes(date) {
            date.setHours(date.getHours() + Math.round(date.getMinutes()/60));
            date.setMinutes(0, 0, 0);
            return date;
          }
          
          const hourPredict = roundedPredictTime.getHours()
          const dayPredict = roundedPredictTime.getDay()
          
          if ((hourPredict >=1 && hourPredict <=4) || (hourPredict == 5 && minutes >30)) {
            const predictOriginText = `<div><p style="padding-bottom: 6px;">Dublin bikes is closed between 12:30am and 5am</p></div>`
            document.getElementById('predictionOrigin').innerHTML = predictOriginText;
          }
          else {
          
          const originNumber = parseInt(document.getElementById("originStationsList").value.split("|")[4])
  
          const recentbike = $.getJSON($SCRIPT_ROOT + "/predictor/" + hourPredict + "/" + dayPredict + "/" + originNumber,
          function(resultData) {
            const predictOriginText = `<div><p style="padding-bottom: 6px;">Expected availability at ${document.getElementById("originStationsList").value.split("|")[2]}: ${resultData[0]}</p></div>`
            document.getElementById('predictionOrigin').innerHTML = predictOriginText;
            // attempt to reduce hang
            document.getElementById('predictionDestinationETA').innerHTML = `<div><p style="padding-bottom: 6px;">Expected ETA at </p></div>`;
            document.getElementById('predictionDestination').innerHTML = `<div><p style="padding-bottom: 6px;">Expected capacity at ETA:</p></div>`;
          }
          
          );
          if (document.getElementById("destinationStationsList").value != -1) {
            
            const destinationNumber = parseInt(document.getElementById("destinationStationsList").value.split("|")[4])
            const stringPredictedETA = predictedArrivalTime.toLocaleTimeString(navigator.language, {hour: '2-digit', minute:'2-digit'}).replace(',','');
            const predictOriginETA = `<div><p style="padding-bottom: 6px;">Expected ETA at ${document.getElementById("destinationStationsList").value.split("|")[2]}: ${stringPredictedETA}</p></div>`
            document.getElementById('predictionDestinationETA').innerHTML = predictOriginETA;
            roundMinutes(predictedArrivalTime)
            const hourCapacity = predictedArrivalTime.getHours()
            const dayCapacity = predictedArrivalTime.getDay()
            // double call to flask to get capacity and predicted availability to avoid model for capacity and availability
            const recentcapacity = $.getJSON($SCRIPT_ROOT + "/predictor/" + hourCapacity + "/" + dayCapacity + "/" + destinationNumber,
            function(resultData) {
              const capacity = $.getJSON($SCRIPT_ROOT + "/occupancy/" + destinationNumber,
            function(totalbikes) {
                const totalBikesStands = parseInt(totalbikes.available_bike_stands) + parseInt(totalbikes.available_bikes);
                const estimatedCapacity = totalBikesStands - resultData[0];
                console.log('capacity', parseInt(totalbikes.available_bike_stands))
                console.log(destinationNumber)
                
            const predictDestinationText = `<div><p style="padding-bottom: 6px;">Expected capacity at ETA: ${estimatedCapacity}</p></div>`
            document.getElementById('predictionDestination').innerHTML = predictDestinationText;
            }
              )} 
          );
          }
          }}
          });
        }

        const test = document.getElementById("btn")
        test.addEventListener('click', calcRoute)
        // Store selection.
        const selectResultItem = function (
          locationIdx,
          panToMarker,
          scrollToResult
        ) {
          locator.selectedLocationIdx = locationIdx;
          for (let locationElem of resultsContainerEl.children) {
            locationElem.classList.remove("selected");
            if (getResultIndex(locationElem) === locator.selectedLocationIdx) {
              locationElem.classList.add("selected");
              if (scrollToResult) {
                panelEl.scrollTop = locationElem.offsetTop;
              }
            }
          }
          if (panToMarker && locationIdx != null) {
            locator.map.panTo(locator.locations[locationIdx].coords);
          }
        };
        // Pans to chosen station in select + zoom
        function chosenstation(){
          let index = document.getElementById("stationsList").value;
          console.log('value', index)
          locator.map.panTo(locator.locations[index].coords);
          // marker.get('index').dispatchEvent(new Event('click'));
          //google.maps.event.trigger(marker.get('index'), 'click')
          // Set zoom level when changing station
          locator.map.setZoom(200);
        };

        document.getElementById("stationsList").onchange = chosenstation;
        // Create one instance of an info window
        const infoWindow = new google.maps.InfoWindow({ minWidth: 400 });
        // const getColour=(i) => {
        //   console.log('i', i)
        //   console.log('number', i.number)
        //     var colour;
        //     const recentbike = $.getJSON($SCRIPT_ROOT + "/occupancy/" + i.number,
        //     function(bikeData) {
        //       if(parseInt(bikeData.available_bikes)>15){
        //         colour = 'http://maps.google.com/mapfiles/ms/icons/green-dot.png'
        //       }
        //       else {
        //         colour = 'http://maps.google.com/mapfiles/ms/icons/red-dot.png'
        //       }
        //       console.log(colour)
        //       return colour
        //     }
        //     )
        //   }

        // const json_means = require("../means_json.json")
        // console.log(json_means)
  
        const weekday = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];

        // Create a marker for each location
        const markers = locator.locations.map(function (location, index) {
          var coloururl;
   
          if (parseInt(colourbike[index]['available_bikes'])<3) {
            coloururl = 'http://maps.google.com/mapfiles/ms/icons/red-dot.png';
          }
          else if (parseInt(colourbike[index]['available_bikes'])<10) {
            coloururl = 'http://maps.google.com/mapfiles/ms/icons/orange-dot.png';
          }
          else {
            coloururl = 'http://maps.google.com/mapfiles/ms/icons/blue-dot.png';
          }
          const marker = new google.maps.Marker({
            position: location.coords,
            map: locator.map,
            title: location.title,
            marker_id: location.number,
            icon: coloururl,
            // icon: getColour(location),
          });
          const visibility = document.getElementById("btn")
  
          visibility.addEventListener("click", changeVis)

          // function to remove markers 
          function changeVis() {
            //const title = document.getElementById("outputGroup")
            
            if(document.getElementById("originStationsList").value == -1 || document.getElementById("destinationStationsList").value == -1){
              // do nothing
          }
          // only remove markers if valid stations selected
          else {
            marker.setVisible(false);
          }
        } 
          const invisibility = document.getElementById("resetbtn")

          invisibility.addEventListener("click", restoreVis)

          // function to reset both selects, remove directions, remove route and back in markers
          function restoreVis() {
            marker.setVisible(true);
            directionsDisplay.setDirections({ routes: [] });
            document.getElementById("outputTitle").innerHTML="";
           
            document.getElementById('output').innerHTML = "";
            document.getElementById('directions').innerHTML = "";
            document.getElementById('predictionOrigin').innerHTML = "";
            document.getElementById('predictionDestinationETA').innerHTML = "";
            document.getElementById('predictionDestination').innerHTML = "";
            document.getElementById('outputGroup').classList.remove("border", "border-secondary", "rounded", "directions", "p-2");
        
            document.getElementById("dateSelection").value = "";
            document.getElementById("originStationsList").value = -1;
            document.getElementById("destinationStationsList").value = -1;
            
          }
        
        // add listener to radio to update marker colours depending on bike/stands selected
        const radioButton = document.getElementById("choices");
        radioButton.addEventListener("change", chosen);
                            
        function chosen() {
          if (document.getElementById("bikeRadio").checked) {
            if (parseInt(colourbike[index]['available_bikes'])<3) {
              marker.setIcon('http://maps.google.com/mapfiles/ms/icons/red-dot.png')
          }
          else if (parseInt(colourbike[index]['available_bikes'])<10) {
            marker.setIcon('http://maps.google.com/mapfiles/ms/icons/orange-dot.png')
          }
          else {
            marker.setIcon('http://maps.google.com/mapfiles/ms/icons/blue-dot.png')
          }
          }
          else {
            if (parseInt(colourbike[index]['available_bike_stands'])<3) {
              marker.setIcon('http://maps.google.com/mapfiles/ms/icons/red-dot.png')
          }
          else if (parseInt(colourbike[index]['available_bike_stands'])<10) {
            marker.setIcon('http://maps.google.com/mapfiles/ms/icons/orange-dot.png')
          }
          else {
            marker.setIcon('http://maps.google.com/mapfiles/ms/icons/blue-dot.png')
          }
          }
        }

          marker.addListener("click", function () {
            console.log(marker.get('marker_id'));
            infoWindow.open({
              anchor: marker,
              map,
              shouldFocus: false,
            });
            const recentbike = $.getJSON($SCRIPT_ROOT + "/occupancy/" + location.number,
            function(bikeData) {
              console.log("BD", bikeData)
              const currentDate = new Date(bikeData.last_update*1);
              const stringCurrentDateTime = currentDate.toLocaleTimeString().replace(',','');
              const stationNumber = parseInt(location.number);
              const displayText = `<div>
                              <h5>${location.address}</h5>
                              <p>Time Updated: ${stringCurrentDateTime}</p>
                              <p>Number of Available Bikes: ${bikeData.available_bikes}</p>
                              <p>Number of Available Bike Stands: ${bikeData.available_bike_stands}</p>
                              </div>
                              <div> 
                                <canvas id="avPerHour"></canvas>
                                <canvas id="avPerWeek"></canvas>
                              </div>`;
              infoWindow.setContent(displayText);
              
              const labelHours = [
                  '06:00',
                  '07:00',
                  '08:00',
                  '09:00',
                  '10:00',
                  '11:00',
                  '12:00',
                  '13:00',
                  '14:00',
                  '15:00',
                  '16:00',
                  '17:00',
                  '18:00',
                  '19:00',
                  '20:00',
                  '21:00',
                  '22:00',
                  '23:00',
                ];

                // Get current day of week
                const d = new Date();
                let day = weekday[d.getDay()];

                const available_stands_hourly = [];
                for (let i = 0; i < hour_means[stationNumber][day].length; i++) {
                  const total_stands = parseInt(bikeData.available_bike_stands) + parseInt(bikeData.available_bikes)
                  available_stands_hourly[i] = total_stands - hour_means[stationNumber][day][i];
                }

                const available_stands_daily = [];
                for (let j = 0; j < day_means[stationNumber].length; j++) {
                  const total_stands = parseInt(bikeData.available_bike_stands) + parseInt(bikeData.available_bikes)
                  available_stands_daily[j] = total_stands - day_means[stationNumber][j];
                }

                const dataAvPerHour = {
                  labels: labelHours,
                  datasets: [
                    {
                    label: 'Available Bikes',
                    backgroundColor: 'rgb(255, 99, 132)',
                    borderColor: 'rgb(255, 99, 132)',
                    data: hour_means[stationNumber][day]
                    }, 
                    {
                      label: 'Available Bike Stands',
                      borderColor: 'rgb(255, 99, 132)',
                      data: available_stands_hourly
                    }
                ]
                };

                const configAvPerHour = {
                  type: 'bar',
                  data: dataAvPerHour,
                  options: {
                    plugins: {
                      title: {
                        display: true,
                        text: 'Average Availability per Hour on ' + day
                      }, 
                      legend: {
                        display: false
                      }
                    },
                    maintainAspectRatio: true,
                    aspectRatio: 2.5,
                    responsive: true,
                    scales: {
                      y: {
                        beginAtZero: true,
                        stacked: true
                      }, 
                      x: {
                        stacked: true,
                        ticks: {
                          maxTicksLimit: labelHours.length / 2
                        }
                      }
                    }
                  }
                };

                const dataAvPerWeek = {
                  labels: weekday,
                  datasets: [
                    {
                    label: 'Available Bikes',
                    backgroundColor: 'rgb(255, 99, 132)',
                    borderColor: 'rgb(255, 99, 132)',
                    data: day_means[stationNumber]
                    }, 
                    {
                      label: 'Available Bike Stands',
                      borderColor: 'rgb(255, 99, 132)',
                      data: available_stands_daily
                    }
                ]
                };

                const configAvPerWeek = {
                  type: 'bar',
                  data: dataAvPerWeek,
                  options: {
                    plugins: {
                      title: {
                        display: true,
                        text: 'Average Availability per Day'
                      }, 
                      legend: {
                        display: false
                      }
                    },
                    maintainAspectRatio: true,
                    aspectRatio: 2.5,
                    responsive: true,
                    scales: {
                      y: {
                        beginAtZero: true,
                        stacked: true
                      }, 
                      x: {
                        stacked: true,
                      }
                    }
                  }
                };

                const avPerHour = new Chart(
                  document.getElementById('avPerHour'),
                  configAvPerHour
                );
                const myChart = new Chart(
                  document.getElementById('avPerWeek'),
                  configAvPerWeek
                );
              })
         
            selectResultItem(index, true, true);
          });
          return marker;
        });

        // Fit map to marker bounds.
        locator.updateBounds = function () {
          const bounds = new google.maps.LatLngBounds();
          if (locator.searchLocationMarker) {
            bounds.extend(locator.searchLocationMarker.getPosition());
          }
          for (let i = 0; i < markers.length; i++) {
            bounds.extend(markers[i].getPosition());
          }
          locator.map.fitBounds(bounds);
        };
        if (locator.locations.length) {
          locator.updateBounds();
        }

        // Get the distance of a store location to the user's location,
        // used in sorting the list.
        const getLocationDistance = function (location) {
          if (!locator.searchLocation) return null;

          // Use travel distance if available (from Distance Matrix).
          if (location.travelDistanceValue != null) {
            return location.travelDistanceValue;
          }

          // Fall back to straight-line distance.
          return google.maps.geometry.spherical.computeDistanceBetween(
            new google.maps.LatLng(location.coords),
            locator.searchLocation.location
          );
        };

        // Render the results list --------------------------------------------------
        const getResultIndex = function (elem) {
          return parseInt(elem.getAttribute("data-location-index"));
        };

        locator.renderResultsList = function () {
          let locations = locator.locations.slice();
          for (let i = 0; i < locations.length; i++) {
            locations[i].index = i;
          }
          if (locator.searchLocation) {
            sectionNameEl.textContent =
              "Nearest locations (" + locations.length + ")";
            locations.sort(function (a, b) {
              return getLocationDistance(a) - getLocationDistance(b);
            });
          } else {
            sectionNameEl.textContent = `All locations (${locations.length})`;
          }
          const resultItemContext = { locations: locations };
          resultsContainerEl.innerHTML = itemsTemplate(resultItemContext);
          for (let item of resultsContainerEl.children) {
            const resultIndex = getResultIndex(item);
            if (resultIndex === locator.selectedLocationIdx) {
              item.classList.add("selected");
            }

            const resultSelectionHandler = function () {
              selectResultItem(resultIndex, true, false);
            };

            // Clicking anywhere on the item selects this location.
            // Additionally, create a button element to make this behavior
            // accessible under tab navigation.
            item.addEventListener("click", resultSelectionHandler);
            item
              .querySelector(".select-location")
              .addEventListener("click", function (e) {
                resultSelectionHandler();
                e.stopPropagation();
              });
          }
        };

        // Optional capability initialization --------------------------------------
        initializeSearchInput(locator);
        initializeDistanceMatrix(locator);

        // Initial render of results -----------------------------------------------
        locator.renderResultsList();
      }

      /** When the search input capability is enabled, initialize it. */
      function initializeSearchInput(locator) {
        const geocodeCache = new Map();
        const geocoder = new google.maps.Geocoder();

        const searchInputEl = document.getElementById("location-search-input");
        const searchButtonEl = document.getElementById(
          "location-search-button"
        );

        const updateSearchLocation = function (address, location) {
          if (locator.searchLocationMarker) {
            locator.searchLocationMarker.setMap(null);
          }
          if (!location) {
            locator.searchLocation = null;
            return;
          }
          locator.searchLocation = { address: address, location: location };
          locator.searchLocationMarker = new google.maps.Marker({
            position: location,
            map: locator.map,
            title: "My location",
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 12,
              fillColor: "#3367D6",
              fillOpacity: 0.5,
              strokeOpacity: 0,
            },
          });

          // Update the locator's idea of the user's country, used for units. Use
          // `formatted_address` instead of the more structured `address_components`
          // to avoid an additional billed call.
          const addressParts = address.split(" ");
          locator.userCountry = addressParts[addressParts.length - 1];

          // Update map bounds to include the new location marker.
          locator.updateBounds();

          // Update the result list so we can sort it by proximity.
          locator.renderResultsList();

          locator.updateTravelTimes();
        };

        const geocodeSearch = function (query) {
          if (!query) {
            return;
          }

          const handleResult = function (geocodeResult) {
            searchInputEl.value = geocodeResult.formatted_address;
            updateSearchLocation(
              geocodeResult.formatted_address,
              geocodeResult.geometry.location
            );
          };

          if (geocodeCache.has(query)) {
            handleResult(geocodeCache.get(query));
            return;
          }
          const request = { address: query, bounds: locator.map.getBounds() };
          geocoder.geocode(request, function (results, status) {
            if (status === "OK") {
              if (results.length > 0) {
                const result = results[0];
                geocodeCache.set(query, result);
                handleResult(result);
              }
            }
          });
        };

        // Set up geocoding on the search input.
        searchButtonEl.addEventListener("click", function () {
          geocodeSearch(searchInputEl.value.trim());
        });

        // Initialize Autocomplete.
        initializeSearchInputAutocomplete(
          locator,
          searchInputEl,
          geocodeSearch,
          updateSearchLocation
        );
      }

      /** Add Autocomplete to the search input. */
      function initializeSearchInputAutocomplete(
        locator,
        searchInputEl,
        fallbackSearch,
        searchLocationUpdater
      ) {
        // Set up Autocomplete on the search input. Bias results to map viewport.
        const autocomplete = new google.maps.places.Autocomplete(
          searchInputEl,
          {
            types: ["geocode"],
            fields: ["place_id", "formatted_address", "geometry.location"],
          }
        );
        autocomplete.bindTo("bounds", locator.map);
        autocomplete.addListener("place_changed", function () {
          const placeResult = autocomplete.getPlace();
          if (!placeResult.geometry) {
            // Hitting 'Enter' without selecting a suggestion will result in a
            // placeResult with only the text input value as the 'name' field.
            fallbackSearch(placeResult.name);
            return;
          }
          searchLocationUpdater(
            placeResult.formatted_address,
            placeResult.geometry.location
          );
        });
      }

      /** Initialize Distance Matrix for the locator. */
      function initializeDistanceMatrix(locator) {
        const distanceMatrixService = new google.maps.DistanceMatrixService();

        // Annotate travel times to the selected location using Distance Matrix.
        locator.updateTravelTimes = function () {
          if (!locator.searchLocation) return;

          const units =
            locator.userCountry === "USA"
              ? google.maps.UnitSystem.IMPERIAL
              : google.maps.UnitSystem.METRIC;
          const request = {
            origins: [locator.searchLocation.location],
            destinations: locator.locations.map(function (x) {
              return x.coords;
            }),
            travelMode: google.maps.TravelMode.DRIVING,
            unitSystem: units,
          };
          const callback = function (response, status) {
            if (status === "OK") {
              const distances = response.rows[0].elements;
              for (let i = 0; i < distances.length; i++) {
                const distResult = distances[i];
                let travelDistanceText, travelDistanceValue;
                if (distResult.status === "OK") {
                  travelDistanceText = distResult.distance.text;
                  travelDistanceValue = distResult.distance.value;
                }
                const location = locator.locations[i];
                location.travelDistanceText = travelDistanceText;
                location.travelDistanceValue = travelDistanceValue;
              }

              // Re-render the results list, in case the ordering has changed.
              locator.renderResultsList();
            }
          };
          distanceMatrixService.getDistanceMatrix(request, callback);
        };
      }
    </script>
  
    <script>

      const data = {{ static_data|tojson }};
      const hour_means = {{ hour_means|tojson }};
      const day_means = {{ day_means|tojson }};
      const weather = {{ recentWeather|tojson }};
      const colourbike = {{ recentbike|tojson }};
      // convert weather to an actual json object (currently string)
      const weatherobj = JSON.parse(weather)
      // convert recentbike to an actual json object (currently string)
      //const recentbikeobj = JSON.parse(recentbike)
      
      //onsole.log(recentbikeobj)
      
      
      
      

      data.map(row => {
          row.coords.lat = parseFloat(row.coords.lat);
          row.coords.lng = parseFloat(row.coords.lng);
      })
      console.log(data);
    const CONFIGURATION = {
      "locations": data,
      "mapOptions": {"center":{"lat":38.0,"lng":-100.0}, "fullscreenControl":true,"mapTypeControl":false,"streetViewControl":false,"zoom":2,"zoomControl":true,"maxZoom":17,"styles":[
      { "elementType": "geometry", "stylers": [{ "color": "#242f3e" }] },
      { "elementType": "labels.text.stroke", "stylers": [{ "color": "#242f3e" }] },
      { "elementType": "labels.text.fill", "stylers": [{ "color": "#746855" }] },
      {
        "featureType": "administrative.locality",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#d59563" }],
      },
      {
        "featureType": "poi",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#d59563" }],
      },
      {
        "featureType": "poi.park",
        "elementType": "geometry",
        "stylers": [{ "color": "#263c3f" }],
      },
      {
        "featureType": "poi.park",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#6b9a76" }],
      },
      {
        "featureType": "road",
        "elementType": "geometry",
        "stylers": [{ "color": "#38414e" }],
      },
      {
        "featureType": "road",
        "elementType": "geometry.stroke",
        "stylers": [{ "color": "#212a37" }],
      },
      {
        "featureType": "road",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#9ca5b3" }],
      },
      {
        "featureType": "road.highway",
        "elementType": "geometry",
        "stylers": [{ "color": "#746855" }],
      },
      {
        "featureType": "road.highway",
        "elementType": "geometry.stroke",
        "stylers": [{ "color": "#1f2835" }],
      },
      {
        "featureType": "road.highway",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#f3d19c" }],
      },
      {
        "featureType": "transit",
        "elementType": "geometry",
        "stylers": [{ "color": "#2f3948" }],
      },
      {
        "featureType": "transit.station",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#d59563" }],
      },
      {
        "featureType": "water",
        "elementType": "geometry",
        "stylers": [{ "color": "#17263c" }],
      },
      {
        "featureType": "water",
        "elementType": "labels.text.fill",
        "stylers": [{ "color": "#515c6d" }],
      },
      {
        "featureType": "water",
        "elementType": "labels.text.stroke",
        "stylers": [{ "color": "#17263c" }],
      },
    ],},
      "mapsApiKey": "AIzaSyAwcd17hVt4kEa00VW5DIv5BYItdB4BnZA",
      "capabilities": {"input":true,"autocomplete":true,"directions":false,"distanceMatrix":true,"details":false}
    };

    // add weather data to div
    
    const weatherDate = new Date(weatherobj['date']*1);
    const weatherDatetime = weatherDate.toLocaleTimeString(navigator.language, {hour: '2-digit', minute:'2-digit'}).replace(',','');

    const weatherDiv = `<p>Temperature: ${weatherobj['temperature']}\u00B0C</p>
                        <p>Time Updated: ${weatherDatetime}<p/>`;

    document.getElementById("currentWeather").innerHTML = weatherDiv;

    // add station name options to select
    const options = data.map((station, idx) => {
      return `<option value=${idx}>${station.address}</option>`
    })
    let select = `<option value='-1'>Select a Bike Station</option>`+`${options}`;
    document.getElementById("stationsList").innerHTML = select;

    const routeOptions = data.map((station, idx) => {
      // console.log(`<option value='${station.coords.lat}|${station.coords.lng}'>${station.address}</option>`)
      return `<option value='${station.coords.lat}|${station.coords.lng}|${station.address}|${idx}|${station.number}'>${station.address}</option>`
    })

    let originSelect = `<option value='-1'>Select a Start Bike Station</option>`+`${routeOptions}`;
    document.getElementById("originStationsList").innerHTML = originSelect;

    let destinationSelect = `<option value='-1'>Select a Destination Bike Station</option>`+`${routeOptions}`;
    document.getElementById("destinationStationsList").innerHTML = destinationSelect;

    function initMap() {
      new LocatorPlus(CONFIGURATION);
    }
  </script>
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAwcd17hVt4kEa00VW5DIv5BYItdB4BnZA&callback=initMap&libraries=places,geometry&solution_channel=GMP_QB_locatorplus_v4_cABD"
      async
      defer
    ></script>

    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
  </body>
</html>
